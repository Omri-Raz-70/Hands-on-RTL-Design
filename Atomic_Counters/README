I asked to design a 64-bit event counter which would be interfaced with a 32-bit bus controlled via a microcontroller.
The 64-bit counter is incremented whenever a trigger input is seen.
Given that the counter is read by a 32-bit bus, a full 64-bit read of the counter needs two 32-bit accesses.
It is important that these two accesses should be single-copy atomic.



# Atomic Counter Module (`atomic_counters`)

## Overview
The **Atomic Counter** is a 64-bit hardware counter designed to interface with a narrower 32-bit data bus.

Its primary feature is an **Atomic Read Mechanism**. Since a 64-bit value cannot be read in a single cycle over a 32-bit bus, this module allows the user to snapshot the upper 32 bits (MSB) while reading the lower 32 bits (LSB). This prevents data "tearing"â€”where the counter increments and rolls over from LSB to MSB between the two read operations, resulting in corrupted data.

## Key Features
* **64-bit Internal Precision:** Maintains a large count range to prevent frequent overflows.
* **Atomic Snapshots:** Ensures data integrity when reading 64-bit values over a 32-bit bus.
* **Configurable Step:** Supports standard increment (+1) and "Fast" increment (+1,000,000) modes.
* **Handshake Interface:** Uses `req` and `ack` signals for data bus synchronization.

## Parameters
| Parameter | Default | Description |
| :--- | :--- | :--- |
| `DATABUS` | 32 | Width of the output data bus. |
| `COUNTLEN` | 64 | Width of the internal counter register. |

## Interface (Ports)

| Port | Direction | Width | Description |
| :--- | :--- | :--- | :--- |
| `clk` | Input | 1 | System Clock. |
| `reset` | Input | 1 | Active High synchronous reset. |
| `trig_i` | Input | 1 | **Trigger:** When high, the counter increments. |
| `req_i` | Input | 1 | **Request:** Initiates a read transaction. |
| `atomic_i` | Input | 1 | **Atomic/Select:** High = Read LSB & Snapshot MSB. Low = Read stored MSB. |
| `fast_i` | Input | 1 | **Fast Mode:** High adds 1,000,000. Low adds 1. used for testing|
| `ack_o` | Output | 1 | **Acknowledge:** Indicates valid data on `count_o` (1 cycle latency). |
| `count_o` | Output | 32 | **Data Output:** The 32-bit data slice requested. |

## Functional Description

### 1. Counting Logic
The counter operation is controlled by `trig_i` and `fast_i`. The counter updates on the rising edge of `clk`.

* **Hold:** If `trig_i = 0`, the counter retains its value.
* **Increment (+1):** If `trig_i = 1` and `fast_i = 0`.
* **Fast Jump (+1M):** If `trig_i = 1` and `fast_i = 1` - 
